 <!DOCTYPE html>
<html>
<<<<<<< Updated upstream
  <head>
    <title>Ej: Cubo</title>
    <style>
      html, body { margin: 0; padding: 0; overflow: hidden; }
    </style>
  </head>
  <body>
    <script src="js/three.min.js"></script>
    <script>
		var scene, aspect, camera, renderer;
		var startTime = Date.now();
    var upArrow = false;
		var downArrow = false;

		
		init();
		animate();
	
		function init(){
			scene = new THREE.Scene();
			aspect = window.innerWidth / window.innerHeight;
			camera = new THREE.PerspectiveCamera( 45, aspect, 0.1, 1000);
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			
      var onKeyDown = function ( event ) {
				switch ( event.keyCode ) {
					case 38: // TRASLADAR EN DIRECCION POSITIVA
						upArrow = true;
						break;
					case 40: // TRASLADAR EN DIRECCION NEGATIVA
						downArrow = true;
						break;
				}
			};	  
		  			
			var onKeyUp = function ( event ) {
				upArrow = false;
				downArrow = false;
			};
      document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );

      //Escena
			var size = 10;
			var arrowSize = 1;
			var divisions = size;
			var origin = new THREE.Vector3( 0, 0, 0 );
			var x = new THREE.Vector3( 1, 0, 0 );
			var y = new THREE.Vector3( 0, 1, 0 );
		  	var z = new THREE.Vector3( 0, 0, 1 );
			var color1 = new THREE.Color( 0xFFFFFF );
		  	var color2 = new THREE.Color( 0x333333 );
		  	var colorR = new THREE.Color( 0xAA3333 );
		  	var colorG = new THREE.Color( 0x33AA33 );
		  	var colorB = new THREE.Color( 0x333366 );
		  
		  	//CREAR LAS GRILLAS PARA EL ESCENARIO
		  	var axesHelper = new THREE.AxesHelper( size );
		  	var gridHelperXY = new THREE.GridHelper( size, divisions, color1, color1);
		  	var gridHelperXZ = new THREE.GridHelper( size, divisions, color2, color2 );
		  	var gridHelperYZ = new THREE.GridHelper( size, divisions, color2, color2 );
            
            //ROTARLAS PARA QUE QUEDEN EN EL ESPACIO ADECUADO
            gridHelperXY.rotateOnWorldAxis ( x, THREE.Math.degToRad(90) );
            gridHelperXZ.rotateOnWorldAxis ( y, THREE.Math.degToRad(90) );
            gridHelperYZ.rotateOnWorldAxis ( z, THREE.Math.degToRad(90) );
            
            //CREAR LAS FLECHAS QUE INDICAN LOS EJES DE COORDENADAS 3D
            var arrowX = new THREE.ArrowHelper( x, origin, arrowSize, colorR );
            var arrowY = new THREE.ArrowHelper( y, origin, arrowSize, colorG );
            var arrowZ = new THREE.ArrowHelper( z, origin, arrowSize, colorB );
			
			//CREAR LAS GEOMETRÍAS
            //Punto
            var geoCubo = new THREE.BoxGeometry(1,1,1);
            //var resZ = 1;
            for( var i = 0; i < geoCubo.faces.length; i++) {
              switch (i) {
                    case 0: case 1: geoCubo.faces[ i ].color = colorR; break;
					          case 2: case 3: geoCubo.faces[ i ].color = colorR; break;
					          case 4: case 5: geoCubo.faces[ i ].color = colorG; break;
				          	case 6: case 7: geoCubo.faces[ i ].color = colorG; break;
					          case 8: case 9: geoCubo.faces[ i ].color = colorB; break;
					          case 10: case 11: geoCubo.faces[ i ].color = colorB; break;
                    
                }
            }
			
			//CREAR LOS MATERIALES
            var material = new THREE.MeshBasicMaterial( { color: color1, vertexColors: THREE.FaceColors } );
			
			//CREAR LOS OBJETOS
			object = new THREE.Mesh(geoCubo, material);
		  
		  	//AGREGAR A LA ESCENA
        scene.add( gridHelperXZ );
		  	scene.add( arrowX );	
		  	scene.add( arrowY );	
		  	scene.add( arrowZ );	
			scene.add( object);
			
			camera.position.x = 5;
			camera.position.y = 10;	 
		  camera.position.z =  10;
      camera.lookAt( origin );
			}
    
    function animate() {
        render();
        requestAnimationFrame( animate );
    }
    
    function render(){
        var dtime = Date.now()-startTime;
        camera.lookAt( 0, 0, 0 );
        renderer.render( scene, camera );
        var tx=0, ty=0, tz=0;
		if(upArrow) {
			tx=1;
		}
		if(downArrow) {
			tx=-1;
		}

		//MATRIZ DE TRASLACIÓN
		var t = new THREE.Matrix4();		//Crear la matriz de traslación
		t.set( 	1, 0, 0, tx,
				    0, 1, 0, ty, 
				    0, 0, 1, tz,
				    0, 0, 0, 1	);

		cubo.applyMatrix(t);				//Aplicar la matriz de traslación al objeto				
		cubo.elementsNeedUpdate = true;	//Avisar que la matriz del objeto ha cambiado


    }
    </script>
  </body>
</html>
=======

<head>
    <title>3 cubos</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #info {
            position: absolute;
            padding: 15px;
            width: 100%;
            text-align: justify;
            color: #00fff2;
    </style>
</head>

<body>
    <div id="info">
        <p id="transf">3 cubos trasnformacion Julian Rodriguez</p>
        Use la FLECHA ARRIBA para mostrar los 3 cubos
        Use la FLECHA ABAJO para devolver al origen<br />
        <br />

    </div>
    <script src="js/three.min.js"></script>
    <script>
        var scene, scene2, aspect, camera, renderer;
        var startTime = Date.now();
        var upArrow = false;
        var downArrow = false;
        var tx = 1;
        var ty = 1;
        var tz = 1;


        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene2 = new THREE.Scene(); //agregamos escena2
            aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            //Escena
            var size = 10;
            var arrowSize = 2
            var divisions = size;
            var origin = new THREE.Vector3(0, 0, 0);
            var x = new THREE.Vector3(1, 0, 0);
            var y = new THREE.Vector3(0, 1, 0);
            var z = new THREE.Vector3(0, 0, 1);
            var color1 = new THREE.Color(0xFFFFFF);
            var color2 = new THREE.Color(0x333333);
            var colorR = new THREE.Color(0xAA3333);
            var colorG = new THREE.Color(0x33AA33);
            var colorB = new THREE.Color(0x333366);

            //CREAR LAS GRILLAS PARA EL ESCENARIO
            var axesHelper = new THREE.AxesHelper(size);
            var gridHelperXY = new THREE.GridHelper(size, divisions, color1, color1);
            var gridHelperXZ = new THREE.GridHelper(size, divisions, color2, color2);
            var gridHelperYZ = new THREE.GridHelper(size, divisions, color2, color2);

            //ROTARLAS PARA QUE QUEDEN EN EL ESPACIO ADECUADO
            gridHelperXY.rotateOnWorldAxis(x, THREE.Math.degToRad(90));
            gridHelperXZ.rotateOnWorldAxis(y, THREE.Math.degToRad(90));
            gridHelperYZ.rotateOnWorldAxis(z, THREE.Math.degToRad(90));

            //CREAR LAS FLECHAS QUE INDICAN LOS EJES DE COORDENADAS 3D
            var arrowX = new THREE.ArrowHelper(x, origin, arrowSize, colorR);
            var arrowY = new THREE.ArrowHelper(y, origin, arrowSize, colorG);
            var arrowZ = new THREE.ArrowHelper(z, origin, arrowSize, colorB);

            //CREAR LAS GEOMETRÍAS
            //Punto
            var geoCubo = new THREE.BoxGeometry(1, 1, 1);
            var geoCubo2 = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            var geoCubo3 = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            //var resZ = 1;
            for (var i = 0; i < geoCubo.faces.length; i++) {
                switch (i) {
                    case 0:
                    case 1:
                        geoCubo.faces[i].color = colorR;
                        break;
                    case 2:
                    case 3:
                        geoCubo.faces[i].color = colorR;
                        break;
                    case 4:
                    case 5:
                        geoCubo.faces[i].color = colorG;
                        break;
                    case 6:
                    case 7:
                        geoCubo.faces[i].color = colorG;
                        break;
                    case 8:
                    case 9:
                        geoCubo.faces[i].color = colorB;
                        break;
                    case 10:
                    case 11:
                        geoCubo.faces[i].color = colorB;
                        break;

                }
            }
            //CREAR LOS MATERIALES
            var material = new THREE.MeshBasicMaterial({
                color: color1,
                vertexColors: THREE.FaceColors
            });
            var material2 = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                wireframe: true
            });

            //CREAR LOS OBJETOS
            var object = new THREE.Mesh(geoCubo, material);
            var object2 = new THREE.Mesh(geoCubo2, material2); //Creando los objetos y arriba materiales.
            var object3 = new THREE.Mesh(geoCubo3, material2);

            //for (var i = 0; i < 4; i++) {
            //CREAR LOS MATERIALES
            //	var material = new THREE.MeshBasicMaterial({
            //		color: color1,
            //		vertexColors: THREE.FaceColors
            //	});
            //CREAR LOS OBJETOS
            //	object = new THREE.Mesh(geoCubo, material);
            //	tx = tx / 2;
            //	ty = ty / 2;                                                        // INTENTANDO CREAR LA FUNCION PERO SE PONE PANTALLA NEGRA, BUSCANDO ERRORES.
            //	tz = tz / 2;
            //	object.elementsNeedUpdate = true;
            //	object2.applyMatrix4(matrizE(tx, ty, tz, alturaC))

            //	scene.add(object);
            //}

            //AGREGAR A LA ESCENA
            scene.add(gridHelperXZ);
            scene.add(arrowX);
            scene.add(arrowY);
            scene.add(arrowZ);
            scene.add(object);
            scene.add(object2);
            scene.add(object3);

            camera.position.x = 5;
            camera.position.y = 10;
            camera.position.z = 10;
            camera.lookAt(origin);

            var t = new THREE.Matrix4();

            t.set(1, 0, 0, 0,
                0, 1, 0, 0.5,
                0, 0, 1, 0, //transladar y trasnformar el objeto1
                0, 0, 0, 1);

            object.applyMatrix(t);
            object.elementNeedUpdate = true;
            var t2 = new THREE.Matrix4();

            t2.set(1, 0, 0, 0,
                0, 1, 0, 0.5,
                0, 0, 1, 0, //transladar y trasnformar el objeto2
                0, 0, 0, 1);

            object2.applyMatrix(t2);
            object2.elementNeedUpdate = true;
            var t3 = new THREE.Matrix4();
            t3.set(1, 0, 0, 0,
                0, 1, 0, 0.5,
                0, 0, 1, 0, //transladar y trasnformar el objeto3
                0, 0, 0, 1);

            object3.applyMatrix(t3);
            object3.elementNeedUpdate = true;

            document.addEventListener("keydown", onDocumentKeyDown, false);

            function onDocumentKeyDown(event) { // para el evento con el teclado
                var keyCode = event.which;

                if (keyCode == 38) {
                    var t = new THREE.Matrix4();

                    t.set(1, 0, 0, 0.5,
                        0, 1, 0, 0, //despues del comando transladar y trasnformar el objeto1
                        0, 0, 1, -0.5,
                        0, 0, 0, 1);

                    object.applyMatrix(t);
                    object.elementNeedUpdate = true;
                    var t2 = new THREE.Matrix4();

                    t2.set(1, 0, 0, 0.5,
                        0, 1, 0, 0.75, //despues del comando transladar y trasnformar el objeto2
                        0, 0, 1, -0.5,
                        0, 0, 0, 1);

                    object2.applyMatrix(t2);
                    object2.elementNeedUpdate = true;

                    var t3 = new THREE.Matrix4();

                    t3.set(1, 0, 0, 0.5,
                        0, 1, 0, 1.13,
                        0, 0, 1, -0.5, //despues del comando transladar y trasnformar el objeto3
                        0, 0, 0, 1);

                    object3.applyMatrix(t3);
                    object3.elementNeedUpdate = true; //https://stackoverflow.com/questions/42958252/how-do-i-move-a-three-js-cube-with-keyboard-input
                } else if (keyCode == 40) {
                    object.position.x = 0.0;
                    object.position.y = 0.5;
                    object.position.z = 0.0;
                    object2.position.x = 0.0; //para volver al orgien 
                    object2.position.y = 0.5;
                    object2.position.z = 0.0;
                    object3.position.x = 0.0;
                    object3.position.y = 0.5;
                    object3.position.z = 0.0;
                }

            }
            render();

        }

        function animate() {
            render();
            requestAnimationFrame(animate);
        }

        function render() {
            var dtime = Date.now() - startTime;
            camera.position.x = 10 * Math.cos(dtime / 10000);
            camera.position.z = 10 * Math.sin(dtime / 10000);
            camera.lookAt(0, 0, 0);

            renderer.render(scene, camera);


        }
    </script>
</body>

</html>
>>>>>>> Stashed changes
